# Cambiar nombre

En un procesador fuera de servicio, la etapa de cambio de nombre es responsable de administrar y mantener la correspondencia entre los registros lógicos y los registros físicos. Al cambiar el nombre de los registros lógicos, se eliminan las dependencias entre las instrucciones y se completa la programación fuera de servicio. El cambio de nombre presentado en esta sección incluye principalmente tres módulos: Rename, RenameTable y FreeList, que son responsables de controlar el nivel de la canalización de cambio de nombre, mantener la tabla de cambio de nombre y mantener los registros libres respectivamente.

## Cambiar nombre de tabla RenameTable

La función de la tabla de cambio de nombre es mantener la relación de mapeo entre registros lógicos y registros físicos. Sus puertos de operación incluyen un conjunto de puertos de lectura `readPorts` y un conjunto de puertos de escritura `specWritePorts`. La tabla de cambio de nombre contiene 32 registros con el ancho de dirección de la pila de registros físicos, que representan las direcciones de registros físicos correspondientes a los 32 registros lógicos. Actualmente, los archivos de registro de punto fijo y de punto flotante tienen cada uno un conjunto de tablas de cambio de nombre. Según futuras ampliaciones de instrucciones, las tablas de cambio de nombre se pueden configurar para registrar más contenido (como el estado de cambio de nombre de los archivos de registro condicionales, archivos de registro vectorial, etc.).

`readPorts` es un conjunto de interfaces de lectura sincrónicas, que genera los datos de lectura de la tabla de cambio de nombre correspondiente en el ciclo T+1 de acuerdo con la dirección de lectura y la señal `hold` del ciclo T. Al utilizar este conjunto de puertos, la dirección de lectura se asigna durante la fase de decodificación y la "retención" se asigna en función del estado de bloqueo de la etapa de canalización correspondiente. Si `hold` es 1, los datos leídos permanecerán sin cambios; de lo contrario, los datos leídos se actualizarán de acuerdo con la última dirección leída.

`specWritePorts` es un conjunto de interfaces de escritura que actualizan la tabla de cambio de nombre en función de la información del nuevo cambio de nombre de instrucción y la reversión de ROB, respectivamente, dependiendo del estado del cambio de nombre o la reversión de ROB. Los datos de escritura del ciclo T se actualizarán en los datos de lectura del ciclo T+1.

Los dos grupos de puertos `archWritePorts` y `debug_rdata` en el código solo se utilizan para depurar y se utilizan para proporcionar información de registro al marco DiffTest.


## Lista de registro gratuita FreeList

FreeList registra el estado de todos los registros libres y su tamaño se puede configurar a través del parámetro de clase `size`. FreeList es esencialmente una cola, que consta de un puntero de entrada en cola, un puntero de salida de cola y un almacenamiento de cola.

Al inicializarse, la FreeList contiene todos los registros físicos disponibles. En nuestro diseño, el registro lógico `i` se asigna inicialmente al registro físico `i`, por lo que FreeList contiene 160 números de registros físicos libres del 32 al 191 en el estado inicial. Al cambiar el nombre, FreeList proporcionará como máximo `RenameWidth` números de registro físico libres para usar. Cuando se libera un registro físico (ROB confirma una instrucción o la revierte), FreeList puede ingresar como máximo `CommitWidth` números de registros físicos libres por tiempo.

En el diseño del procesador Xiangshan, se admiten múltiples referencias para registros físicos de punto fijo, y la cantidad de veces que se hace referencia a cada registro físico se registra a través de una tabla de conteo de referencias (RefTable). A través del conteo de referencias, Xiangshan admite la asignación de múltiples registros lógicos al mismo registro físico y admite la optimización de eliminación (eliminación de movimiento) de instrucciones de movimiento. En este caso, el número de registros físicos libres puede teóricamente ser hasta el número total de registros físicos: 1. Por lo tanto, en los procesadores Xiangshan, el tamaño de FreeList de punto fijo es el mismo que el tamaño del archivo de registro físico (el valor predeterminado es 192), y el tamaño de FreeList de punto flotante es la cantidad de archivos de registro físico: 32 (el valor predeterminado es 160).

Actualmente, hay dos implementaciones de FreeList en Xiangshan, que se utilizan cuando no hay función de conteo de referencias o no, correspondientes a `StdFreeList` y `MEFreeList`. En el caso en que no haya recuento de referencias, cuando se produce una reversión de ROB, los registros libres liberados en FreeList deben ser aquellos que se asignaron justo antes, y la cantidad de nuevos registros físicos que se deben asignar en la instrucción de reversión es la mismo. En este caso, no es necesario escribir repetidamente el almacenamiento FreeList, solo hay que hacer retroceder el puntero de desencolado hacia adelante. En el caso del recuento de referencias, debido a la existencia de referencias duplicadas (no se requiere asignación a través de FreeList, pero se aumenta el recuento de referencias de un registro físico), la cantidad de registros físicos revertidos no es necesariamente la misma que la cantidad de registros liberados en FreeList. En este caso, FreeList necesita mantener varios puertos de escritura para facilitar el mantenimiento de los registros físicos reales liberados a través del mecanismo de conteo de referencias.

### Tabla de recuento de referencias RefTable

Como se mencionó anteriormente, la función de la tabla de recuento de referencias es registrar la cantidad de veces que se hace referencia a cada registro físico, con asignación `allocate` (aumentar la cantidad de referencias), desasignación `deallocate` (reducir la cantidad de referencias) , y liberación de registros físicos (a FreeList) `freeRegs` Tres conjuntos de interfaces de módulo.

En presencia de conteo de referencias, cada asignación y desasignación de registro físico se notifica al RefCounter mediante un cambio de nombre. Cuando el valor de recuento de referencia de un registro físico llega a ser 0, el registro físico correspondiente se liberará en la FreeList y esperará la próxima asignación. Por cuestiones de tiempo, la liberación del registro físico se retrasará dos tiempos.

## Cambiar nombre

La función principal de la etapa de cambio de nombre de la canalización es actualizar la información del registro físico de la instrucción, incluidos `psrc`, `pdest` y `old_pdest`. `psrc` y `old_pdest` generalmente provienen de una tabla de cambio de nombre. Cuando una instrucción necesita asignar un nuevo registro físico, como una instrucción de punto fijo que necesita escribir en la pila de registros y el registro de destino no es el registro cero, o una instrucción de punto flotante que necesita escribir en la pila de registros , `pdest` proviene del resultado de la asignación de `FreeList`. Debido a la existencia de dependencias entre instrucciones, para las instrucciones renombradas en el mismo beat, el módulo Rename debe ser responsable de omitir los números de registro físicos entre ellas. Por ejemplo, cuando la instrucción 1 necesita usar el resultado de la instrucción 0, el correspondiente Operación de origen de la instrucción 1 El número debe provenir del registro de destino de la instrucción 1.

El procesador Xiangshan implementa la función de eliminación de movimiento. En este caso, no se asigna ningún registro físico nuevo para la instrucción de movimiento. En su lugar, su registro lógico de destino se renombra directamente al registro físico correspondiente al operando de origen.

El procesador Xiangshan también implementa la omisión de operandos para pares de instrucciones LUI y LOAD. En este caso, la dirección base de la instrucción LOAD será reemplazada por un valor inmediato (en lugar del registro de destino de la LUI). El reemplazo se realiza cambiando la srcType La modificación se completa y el valor inmediato se almacenará en los campos psrc e imm.

En la implementación actual, por cuestiones de tiempo, hemos realizado las siguientes optimizaciones: utilizamos principalmente estrategias conservadoras en lugares donde se requiere la asignación y el arbitraje de recursos. Por ejemplo, cuando no hay un registro físico de punto flotante libre, bloquearemos la tubería. incluso si solo hay instrucciones de punto fijo; dado que las instrucciones son estrictamente continuas en el ROB, asignamos números ROB a las instrucciones por adelantado durante la fase de cambio de nombre, pero aún determinamos el arbitraje de puesta en cola del ROB en la fase posterior, de modo que el número real de Los elementos disponibles en el ROB no se pierden. Sin afectar el rendimiento, la optimización de la sincronización se logra bloqueando el nivel número uno del ROB con anticipación y agregando docenas de registros.
