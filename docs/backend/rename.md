# Rename

In an out-of-order processor, the renaming stage is responsible for managing and maintaining the mapping between logical registers and physical registers. By renaming logical registers, the dependencies between instructions are eliminated and out-of-order scheduling is completed. The renaming introduced in this section mainly includes three modules: Rename, RenameTable, and FreeList, which are responsible for the control of the Rename pipeline level, the maintenance of the renaming table, and the maintenance of free registers.

## Rename Table

The function of the renaming table is to maintain the mapping relationship between logical registers and physical registers. Its operation ports include a set of read ports `readPorts` and a set of write ports `specWritePorts`. The renaming table contains 32 registers with a physical register stack address width, which represent the physical register addresses corresponding to the 32 logical registers. At present, there is a set of renaming tables for each fixed-point and floating-point register stack. According to the future instruction expansion, the renaming table can be configured to record more content (such as the renaming status of the conditional register stack, vector register stack, etc.).

`readPorts` is a set of synchronous read interfaces. In T+1 cycle, the corresponding rename table read data is output according to the read address and `hold` signal of T cycle. When using this set of ports, the read address will be assigned in the decoding stage, and `hold` will be assigned according to the blocking of the corresponding pipeline stage. If `hold` is 1, the read data will remain unchanged, otherwise the read data will be updated according to the latest read address.

`specWritePorts` is a set of write interfaces. According to the status of renaming or ROB rollback, the rename table is updated according to the information of new instruction renaming and ROB rollback respectively. The write data of T cycle will be updated to the read data of T+1 cycle.

The two groups of ports `archWritePorts` and `debug_rdata` in the code are only used for debugging, to provide register information for the DiffTest framework.

## Free register list FreeList

FreeList records the status of all free registers, and its size can be configured through the class parameter `size`. FreeList is essentially a queue, consisting of an entry pointer, a dequeue pointer, and a queue storage.

At initialization, FreeList contains all available physical registers. In our design, the logical register `i` is initially mapped to the physical register `i`, so FreeList contains 160 free physical register numbers from 32 to 191 in the initial state. When renaming, FreeList will give up to `RenameWidth` free physical register numbers for use. When the physical register is released (ROB commits instructions or rolls back), FreeList can enter up to `CommitWidth` free physical register numbers per beat.

In the design of the Xiangshan processor, multiple references are supported for fixed-point physical registers, and the number of times each physical register is referenced is recorded through a reference count table (RefTable). Through reference counting, Xiangshan supports mapping multiple logical registers to the same physical register and supports Move Elimination optimization for Move instructions. In this case, the number of free physical registers can theoretically reach up to the total number of physical registers - 1. Therefore, in Xiangshan processors, the fixed-point FreeList size is the same as the physical register stack size (default is 192), and the floating-point FreeList size is the number of physical register stacks - 32 (default is 160).

Currently, there are two implementations of FreeList in Xiangshan, which are used in the absence/presence of reference counting, corresponding to `StdFreeList` and `MEFreeList`. In the case where there is no reference counting, when a ROB rollback occurs, the free registers released in FreeList must be those that were allocated just before, and the same as the number of new physical registers that need to be allocated in the rollback instruction. In this case, the storage of FreeList does not need to be written repeatedly, and only the dequeue pointer needs to be rolled back. In the case of reference counting, due to the existence of repeated references (no allocation through FreeList, but increasing the reference count of a physical register), the number of physical registers rolled back is not necessarily the same as the number of physical registers released by FreeList. In this case, FreeList needs to maintain several write ports to facilitate the maintenance of the actual released physical registers through the reference counting mechanism.

### Reference Count Table RefTable

As mentioned above, the reference count table is used to record the number of times each physical register is referenced. It has three sets of module interfaces: allocation `allocate` (increase the number of references), de-allocation `deallocate` (reduce the number of references), and release of physical registers (to FreeList) `freeRegs`.

In the case of reference counting, the allocation and release of each physical register will be notified to RefCounter by renaming. When the reference count value of a physical register becomes 0, the corresponding physical register will be released into FreeList and wait for the next allocation. For timing considerations, the release of physical registers will be delayed by two beats.

## Rename

The main function of the rename pipeline is to update the physical register information of the instruction, including `psrc`, `pdest` and `old_pdest`. `psrc` and `old_pdest` are generally derived from the rename table. When an instruction needs to allocate a new physical register, such as when a fixed-point instruction needs to write to the register stack and the destination register is a non-zero register, and when a floating-point instruction needs to write to the register stack, `pdest` comes from the allocation result of `FreeList`. Due to the existence of dependencies between instructions, for instructions that are renamed in the same beat, the Rename module needs to be responsible for bypassing the physical register number between them. For example, when instruction 1 needs to use the result of instruction 0, the corresponding source operand of instruction 1 needs to come from the destination register of instruction 1.

The Xiangshan processor implements the Move Elimination function. In this case, no new physical register is allocated for the Move instruction, but its destination logical register is directly renamed to the physical register corresponding to the source operand.

The Xiangshan processor also implements operand bypass for LUI and LOAD instruction pairs. In this case, the base address of the LOAD instruction will be replaced by an immediate value (instead of the destination register of the LUI). The replacement is completed by modifying the srcType, and the immediate value will be stored in the psrc and imm fields.

In the current implementation, for timing considerations, we have made the following optimizations: conservative strategies are mostly used in locations where resource allocation and arbitration are required. For example, when there is no free floating-point physical register, we will block the pipeline even if there are only fixed-point instructions in the pipeline; because instructions are strictly continuous in the ROB, we assign ROB numbers to instructions in advance during the renaming stage, but still judge the ROB enqueue arbitration in the subsequent stage. In this way, the timing optimization can be completed by latching the ROB number one level in advance and adding dozens of registers without losing the actual number of available items in the ROB and affecting performance.
