# FPGA Prototype

Guide to building an open source FPGA minimum system based on Nanhu

## Basic steps

### Compile Xiangshan Nanhu RTL

(1) The main branch (Kunming Lake architecture) is under continuous development. The tape-out version of the Nanhu architecture is designed in the nanhu branch, and the branch adapted to the FPGA environment is in [nanhu-clockdiv2](https://github.com/OpenXiangShan/XiangShan/tree/nanhu-clockdiv2)

Note:

* Because the FPGA code and the simulation code are not the same set, if you use the same XiangShan repository, you need to `rm -rf build` to delete the existing output files

* The dual-core Nanhu code has been tailored according to the FPGA resource capacity. Currently, the dual-core is submitted for FPGA verification with [09d2a32142c64fca898e17c0b943e61ddc331958](https://github.com/OpenXiangShan/XiangShan/commit/09d2a32142c64fca898e17c0b943e61ddc331958).

(2) Pull the repository from GitHub

```sh
git clone https://github.com/OpenXiangShan/XiangShan
cd XiangShan
export NOOP_HOME=$(pwd)
git checkout 09d2a32142c64fca898e17c0b943e61ddc331958
make init
make clean
make verilog NUM_CORES=2 # Dual-Core XiangShan
```

(3) Make some modifications to the generated code to allow Vivado to call the ultra ram resources during instantiation. For example: in the file starting with array_, declare a 64-bit RAM with a depth greater than 1024, force Vivado to use ultra RAM to instantiate, and reduce the use of bram

Modify `array_16_ext.v`:

![array_16_ext.png](../../figs/fpga_images/array_16_ext.png)

### Copy Vivado related scripts, generate Vivado projects, and compile binary streams

```sh
# prepare the scripts
git clone https://github.com/OpenXiangShan/env-scripts.git
cd xs_nanhu_fpga
make update_core_flist CORE_DIR=$NOOP_HOME/build
make nanhu CORE_DIR=$NOOP_HOME/build

# generate the FPGA bitstream
make bitstream CORE_DIR=$NOOP_HOME/build
```

Note: The generation time is long. Depending on the performance of the machine, it takes 8~12 hours to complete the bit generation

### Download test

Script: [onboard-ai1-119.tcl](https://raw.githubusercontent.com/OpenXiangShan/env-scripts/main/fpga/onboard-ai1-119.tcl)

Instance memory image txt: [data.txt](https://raw.githubusercontent.com/OpenXiangShan/XiangShan-doc/main/docs/integration/resources/data.zip) (Download the zip file and then unzip it into txt)

The first path after `-tclargs` is `<vivado_build_folder>` for storing the bit and ltx files generated by Vivado

```sh
vivado -mode batch -source ./onboard-ai1-119.tcl -tclargs <vivado_build_folder> ./data.txt
```

Connect to the serial port, 115200, N, 8, 1

<font color=red>*Username: root*</font>

<font color=red>*Password: bosc*</font>

After the system is loaded, you can see the following information. You can get the current CPU information by `cat /proc/cpuinfo`:

![cpuinfo.png](../../figs/fpga_images/cpuinfo.png)

## FPGA Minimum System Principle

### XiangShan Core Interface

The external interface of XiangShan CPU core mainly includes MEM AXI, DMA AXI and CFG AXI. They are used to connect to DDR controller, DMA data path and IO operation respectively.

![fpga_minimal.png](../../figs/fpga_images/fpga_minimal.png)

![nanhu_interface.png](../../figs/fpga_images/nanhu_interface.png)

When we built the minimum system, we mainly used the MEM AXI and CFG AXI interfaces because there was no large data throughput operation.

### XiangShan address mapping table (CFG AXI)

The following is the address mapping table of XiangShan. When building the minimum system, we only need a few peripherals: `SYS_CFG`, `QSPI_FLASH` and `UART`. Therefore, we built a bridge to connect to CFG AXI in Vivado and led out the three peripherals mentioned above according to the address mapping table of XiangShan.

`QSPI_FLASH` mainly stores bootrom. In the Vivado project, we use bram with initial values ​​to simulate it.

`SYS_CFG` only uses the version information at offset 0x0000_0000.

```cpp #ifndef _XS_MEMMAP_H_ #define _XS_MEMMAP_H_ #define QSPI_FLASH_BASE 0x10000000 #define DMA_BASE 0x30040000 #define SDMMC_BASE 0x30050000 #define USB_BASE 0x30060000 #define QSPI_BASE 0x31000000 #define GMAC_BASE 0x31010000 #define HDMI_BASE 0x31020000 #define HDMI_PHY_BASE 0x31030000 #define DP_BASE 0x31040000 #define DDR0_BASE 0x31060000 #define DDR0_PHY_BASE 0x31070000 #define I2S_BASE 0x310A0000 #define UART0_BASE 0x310B0000 #define UART1_BASE 0x310C0000 #define UART2_BASE 0x310D0000 #define I2C0_BASE 0x310E0000 #define I2C1_BASE 0x310F0000 #define I2C2_BASE 0x31100000 #define I2C_BASE I2C0_BASE #define GPIO_BASE 0x31110000 #define CRU_BASE 0x31120000 #define WDT_BASE 0x31130000 #define USB2_PHY0_BASE 0x31140000 #define USB2_PHY1_BASE 0x31150000 #define USB3_PHY0_BASE 0x31180000 #define USB3_PHY1_BASE 0x31190000 #define SOC_REG_BASE 0x31200000 #define PCIE0_CFG_BASE 0x311C0000 #define PCIE1_CFG_BASE 0x311D0000 #define SYSCFG_BASE 0x31200000 #define PMA_CFG0_BASE 0x38021000 #define PMA_CFG2_BASE 0x38021010 #define PMA_ADDR_BASE(x) (0x38021100 + 8 * x) #define CPU_CFG_BASE 0x3a000000 #define PCIE0_BASE 0x40000000 #define PCIE1_BASE 0x60000000 #define DDR_BASE 0x80000000 #define UART_BASE UART0_BASE #define SYNC_ADDR QSPI_FLASH_BASE + 0x07000000 #endif //_XS_MEMMAP_H_
```

![cfg_axi.png](../../figs/fpga_images/cfg_axi.png)

### XiangShan MEM AXI interface design

MEM AXI interface is relatively simple, mainly connecting XiangShan to the DDR controller. A JTAG to AXI IP will be added to the FPGA to implement the operation of loading the Linux image file to the DDR address.

![ddr_block.png](../../figs/fpga_images/ddr_block.png)

### From the downloaded script, see the startup process

(1) Get the bit file path

```tcl
# param
# first : xiangshan's bit
# second : workload's data.txt
set xs_path [lindex $argv 0]
puts "xiangshan path:"
puts $xs_path
set bit_path $xs_path/xs_fpga_top_debug.bit
set ltx_path $xs_path/xs_fpga_top_debug.ltx
puts "bit_path:"
puts $bit_path
puts "ltx_path:"
puts $ltx_path
```

(2) Open the hw_server of the corresponding server and burn FPGA ```tcl open_hw_manager connect_hw_server -url localhost:3121 -allow_non_jtag current_hw_target [get_hw_targets */xilinx_tcf/Xilinx/00500208D0BAA] set_property PARAM.FREQUENCY 10000000 [get_hw_targets */xilinx_tcf/Xilinx/00500208D0BAA] open_hw_target set_property PROBES.FILE $ltx_path [get_hw_devices xcvu19p_0] set_property FULL_PROBES.FILE $ltx_path [get_hw_devices xcvu19p_0] set_proper
